package com.sedat.databases;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * java.sql.Connection class commits the changes automatically as soon as we execute a query which is sometimes what we want but often it is not.
 * for example if we are debitting one account and crediting another and one statement executes successfully but the other one doesn't in which case we have incorrect state.
 * So it would be nice when we want to accomplish something that requires multiple sql statements, we could run all those statements as a single unit.
 * Either all those statements would succeed or none of them would commit.
 * 
 * So a Transaction is a sequence of SQL statements treated as a single logical unit. If any of the transactions fail, the result of any previous transaction would rolled back.
 * Database transactions must be ACID-compliant
 * A - Atomic - if a series of sql statments changes the db; either all of them commit or none
 * C - Consistency - Before a transaction begins the db is in a valid state, and after it completes the db is still in a valid state.
 * I - Isolation - until the changes committed by a transaction are completed they won't be visible to other connections. Transactions can't depend on each other
 * D - Durability - Once the changes performed by a transaction committed to the db, they are permanent. 
 * 
 * You don't need to use transactions if your only querying the db and not changing anything in it.
 * 
 * It is also possible to rollback a transaction to a certain point rather than rolling back everything. To do this you need to call
 * conn.setSavePoint which returns a save point object, and when you need to roll back you pass this object in the rollback() call
 */
public class Transactions {
	
	private static String url = "jdbc:sqlite:C:\\Users\\sedat.turkoglu\\Documents\\workspaces\\java-tutorials\\src\\com\\sedat\\databases\\music.db";
	private static Connection con;

	public static void main(String[] args) {
		
		String insertartist = "insert into artists(name) values(?)";
		String insertalbums = "insert into albums(name, artist) values(?, ?)";
		String insertsongs = "insert into songs(track, title, album) values(?,?,?)";
		
		PreparedStatement psartist;
		PreparedStatement psalbum;
		PreparedStatement pssong;
		
		try {			
			con = DriverManager.getConnection(url);
			//first disable the auto commit
			con.setAutoCommit(false);
			
			//when we include Statement.RETURN_GENERATED_KEYS in the conn.prepareStatement, then we are able to retrieve the id generated by the db for that particular entry
			psartist = con.prepareStatement(insertartist, Statement.RETURN_GENERATED_KEYS);
			psalbum = con.prepareStatement(insertalbums, Statement.RETURN_GENERATED_KEYS);
			pssong = con.prepareStatement(insertsongs);
			
			String artistName = "new artist";
			String albumtName = "new album";
			String songName = "new song";
			
			if(queryTable(artistName, "artists", "name", con) < 0) {
				//we need to insert a new row
				psartist.setString(1, artistName);
				int affectedRows = psartist.executeUpdate();
				ResultSet generatedKey = psartist.getGeneratedKeys();
				if(generatedKey.next()) {
					System.out.println(generatedKey.getInt(1));
				}
			}else {
				//means we already have the artist record
			}
			
			/**
			 * basically you perform all the checks that each sql statement succeeded with no error,
			 * you also check your business logic and not put duplicates into the db
			 * after all is good you do con.commit() otherwise conn.rollback() 
			 */
		}catch(SQLException e) {
			e.printStackTrace();
			System.out.println(e);
		}finally {
			try {
				con.setAutoCommit(true);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		
	}
	
	public static int queryTable(String recordName, String tableName, String columnName, Connection con) {
		String sql = "select _id from " + tableName + " where " + columnName + "=" + "'" + recordName + "'";
		System.out.println(sql);
		int res = -1;
		try {
			Statement st = con.createStatement();
			ResultSet rs = st.executeQuery(sql);
			if(rs.next()) {
				res =  rs.getInt(1);				
			}
		}catch(SQLException e) {
			e.printStackTrace();
			System.out.println(e.getMessage());
		}
		return res;
	}

}





















